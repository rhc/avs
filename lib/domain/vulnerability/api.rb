# frozen_string_literal: true

require_relative 'model'

class InsightVMApi
  def fetch_vulnerabilities
    fetch_all('/vulnerabilities') do |resource|
      yield Vulnerability.from_json(resource)
    end
  end

  def fetch_vulnerability(site_id)
    fetch("/vulnerabilities/#{site_id}") do |data|
      return Vulnerability.from_json(data)
    end
    nil
  end

  def fetch_vulnerability_by_name(name)
    fetch_vulnerabilities do |vulnerability|
      return vulnerability if vulnerability.name.downcase == name.downcase
    end
    nil
  end

  def fetch_utr_vulnerabilities
    vulnerabilities = []
    fetch_vulnerabilities do |vulnerability|
      vulnerabilities << vulnerability if vulnerability.utr?
    end
    vulnerabilities
  end

  def delete_utr_vulnerabilities
    puts 'Fetching UTR vulnerabilities can take up to 5 minutes, patience ...'
    vulnerabilities = fetch_utr_vulnerabilities
    # TODO: add progress bar
    raise 'No UTR vulnerabilities were found.' if vulnerabilities.empty?

    # TODO: ask for confirmation
    puts "#{vulnerabilities.count} vulnerabilities will be deleted. Are you sure?"
    vulnerabilities.each do |vulnerability|
      next unless vulnerability.utr? # double-check

      puts "Deleting vulnerability #{vulnerability.name}"

      delete_vulnerability(vulnerability.id)
    end
  end

  def create_vulnerability(
    name:,
    description:,
    engine_id:,
    scan_template_id:,
    importance: 'normal',
    included_targets: [],
    excluded_targets: [],
    included_asset_group_ids: [],
    excluded_asset_group_ids: []
  )
    # Construct the request body
    params = {
      name:,
      description:,
      importance:,
      engineId: engine_id,
      scanTemplateId: scan_template_id,
      scan: {
        assets: {
          includedTargets: {
            addresses: included_targets
          },
          excludedTargets: {
            addresses: excluded_targets
          },
          includedAssetGroups: {
            assetGroupIDs: included_asset_group_ids
          },
          excludedAssetGroups: {
            assetGroupIDs: excluded_asset_group_ids
          }
        }
      }
    }
    result = post('/vulnerabilities', params)
    result&.dig('id')
  end

  def create_utr_vulnerabilities_for(
    business_unit:,
    cmdb_assets:,
    cached_tags: {},
    starts_discovery: true
  )
    assets = cmdb_assets.select { |asset| asset.business_unit == business_unit }
    vulnerability_names = assets.map(&:vulnerability_name).uniq
    vulnerability_names.each do |vulnerability_name|
      vulnerability_id = create_utr_vulnerability_from(
        vulnerability_name:,
        cmdb_assets: assets,
        cached_tags:
      )
      if vulnerability_id.nil?
        puts "Cannot create #{vulnerability_name} vulnerability"
        next
      end

      puts "\tCreate asset group: #{vulnerability_name}"
      create_asset_group_for(vulnerability_id:, vulnerability_name:)

      puts "\tSchedule the scan"
      # TODO

      next unless starts_discovery

      puts "\tStart discovery scan"
      starts_discovery_scan(vulnerability_id:)
    end
  end

  # return day of week and starts Time
  # of scan ScanSchedule
  # given the UTR digits
  def scan_slot(utr_digits)
    index = utr_digits % 25
    day = index / 5
    hour = index % 5

    days = %w[monday tuesday friday saturday sunday]
    hours = [20, 22, 0, 2, 4]

    {
      day_of_week: days[day],
      start_time: hours[hour]
    }
  end

  def create_utr_vulnerability_schedule(vulnerability_id:)
    vulnerability = fetch_vulnerability(vulnerability_id)
    raise 'The vulnerability is not a valid UTR vulnerability' unless vulnerability.utr?

    scan_name = vulnerability.name
    vulnerability.utr_digits
    slot = scan_slot(vulnerability.utr_digits)
    scan_template_id = vulnerability.scan_template_id
    duration_in_hours = 2

    create_weekly_scan(
      day_of_week: slot[:day_of_week],
      start_time: slot[:start_time],
      duration_in_hours:,
      vulnerability_id:,
      scan_name:,
      scan_template_id:
    )
  end

  def fetch_discovery_scan_template_id(country)
    if country == 'South Africa'
      settings[:za_discovery_template_id]
    else
      settings[:ar_discovery_template_id]
    end
  end

  # return vulnerability.id if success
  # only return the onboard assets
  def create_utr_vulnerability_from(
    vulnerability_name:, cmdb_assets:, cached_tags: {}
  )
    assets = cmdb_assets.select { |asset| asset.vulnerability_name == vulnerability_name }
                        .select(&:onboard?)

    return if assets.empty?

    country = assets.first.country
    targets = assets.map(&:fqdn)
    scan_engine_pool = fetch_country_scan_engine_pools(country)
    # puts "Scan engine pool #{scan_engine_pool}"
    engine_id = scan_engine_pool[:id]
    scan_template_id = fetch_discovery_scan_template_id(country)
    puts
    puts '-' * 40
    puts "Vulnerability #{vulnerability_name}\nTargets: #{targets.length} #{targets.join(' ')}"
    puts '-' * 40

    # TODO: check if the vulnerability already exists
    vulnerability_id = create_utr_vulnerability(
      name: vulnerability_name,
      description: vulnerability_name,
      targets:,
      engine_id:,
      scan_template_id:
    )
    if vulnerability_id.nil?
      puts "Vulnerability #{vulnerability_name} already exists!"
      return
    end

    # add vulnerability credential
    shared_credential = fetch_cyberark(country)
    puts "\tAdd credential: #{shared_credential.name}"
    credential_id = shared_credential.id
    add_vulnerability_shared_credentials(vulnerability_id:, credential_id:)

    # tag assets with business unit code, sub_area, app + utr,
    tag_names = assets.first.utr_tag_names
    tags = tag_names.map do |tag_name|
      puts "\tAdd tag: #{tag_name}"
      upsert_tag(name: tag_name, cached_tags:)
    end
    tag_ids = tags.map(&:id)

    add_utr_tags(vulnerability_id:, tag_ids:)
    vulnerability_id
  end

  def add_utr_tags(vulnerability_id:, tag_ids:)
    tag_ids.each do |tag_id|
      put("/vulnerabilities/#{vulnerability_id}/tags/#{tag_id}", nil)
    end
  end

  def starts_discovery_scan(vulnerability_id:)
    vulnerability = fetch_vulnerability(vulnerability_id)
    raise "Vulnerability ##{vulnerabilityId} does not exist." if vulnerability.nil?

    params = {}
    post("/vulnerabilities/#{vulnerability_id}/scans", params)
  end

  def delete_vulnerability_by(site_idte_idte_idte_id:, name:)
    raise 'Specify either id or name' if site_idte_id.nil? && name.nil?

    if site_idte_id
      delete_vulnerability(site_idte_id)
    else
      vulnerability = fetch_vulnerability_by_name(name)
      delete_vulnerability(vulnerability.site_idte_id)
    end
  end

  def delete_vulnerability(site_id)
    raise 'Cannot delete vulnerability without id' if site_id.nil?

    vulnerability = fetch_vulnerability(site_id)
    raise "Vulnerability #{site_id} does not exist." if vulnerability.nil?

    puts 'Delete asset group with the same name as the vulnerability'
    delete_asset_group_by(name: vulnerability.name)

    puts "Delete assets from vulnerability #{site_id}"
    delete("/vulnerabilities/#{site_id}/assets", '')
    puts "Delete vulnerability #{site_id}"
    delete('/vulnerabilities', site_id)
  end

  def create_utr_vulnerability(
    name:,
    description:,
    targets:,
    engine_id:,
    scan_template_id:
  )
    create_vulnerability(
      name:,
      description:,
      importance: 'high',
      engine_id:,
      scan_template_id:,
      included_targets: targets
    )
  end

  def fetch_vulnerability_with_second_step(spreadsheet, tabsheet_name: 'vulnerability_with_second_step')
    xlsx = Roo::Excelx.new(spreadsheet)
    sheet = xlsx.sheet(tabsheet_name)
    headers = xlsx.row(1)
    p headers
    models = []
    total_rows = sheet.last_row - 1
    progress_bar = ProgressBar.create(
      title: "Processing #{spreadsheet}",
      total: total_rows,
      format: '%a %B %p%% %t'
    )
    xlsx.each_row_streaming(offset: 1, pad_cells: true) do |row|
      values = row.map { |cell| clean_value(cell&.value) }
      attributes = Hash[headers.zip(values)]
      model = VulnerabilityWithSecondStep.new(attributes)
      models << model unless model.cve_number.nil?

      progress_bar.increment
    end
    models
  end
end

def clean_value(value)
  value = value.to_s.strip
  return nil if value.empty?

  value = value.gsub(/\A['"]|['"]\Z/, '') # Remove leading/trailing quotes
  value = value.gsub(/\s+/, ' ')  # Replace multiple spaces with a single space
  value = value.gsub(/\\n/, "\n") # Replace literal '\n' with actual newlines
  value.gsub(/\A\n+|\n+\Z/, '') # Remove leading/trailing newlines
end
